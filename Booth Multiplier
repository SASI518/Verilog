module booths_multiplier(q,m,prod);
    parameter bit_width = 8; //bit width is generalized
    input signed [bit_width-1 : 0] q,m;
    output  reg signed [2*(bit_width)-1 : 0] prod;
    
    reg signed [2*(bit_width) : 0] res;
    wire [bit_width-1 : 0] ac = {bit_width{1'b0}};
    wire q_ext = 1'b0;
    wire signed [bit_width-1 : 0] mbar =~(m) + 1'b1; // performs the 2's complement
    
    integer i;
    
    always @(*)
        begin
            res = {ac,q,q_ext}; //Initialization
            for (i=0;i<bit_width;i=i+1) //performs iterations
                begin
                    case({res[1],res[0]})
                        2'b01 : begin
                                    res[2*bit_width:bit_width+1] = res[2*bit_width:bit_width+1] + {{bit_width{m[bit_width-1]}}, m}; //performs the addition and also makes sure that the sign bit is not getting truncated
                                    res = res >>> 1; // arithmetic right shift by 1 bit
                                end
                        2'b10 : begin
                                    res[2*bit_width:bit_width+1] = res[2*bit_width:bit_width+1] + {{bit_width{m[bit_width-1]}}, mbar}; //performs the addition and also makes sure that the sign bit is not getting truncated
                                    res = res >>> 1; // arithmetic right shift by 1 bit
                                end
                        default : res = res >>> 1;
                     endcase
                 end
                 prod = res[2*bit_width:1];
         end
                    
            
    
endmodule
